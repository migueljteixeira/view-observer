{"version":3,"file":"view-observer.js","sources":["../src/utils.js","../src/main.js"],"sourcesContent":["export default function unflatten(array) {\n  return Array.isArray(array) ? array : [array];\n}\n","import unflatten from \"./utils\";\n\nexport default class {\n  constructor(options) {\n    this.intersectionObserver = new IntersectionObserver(\n      (entries, observer) => {\n        entries.forEach(entry => {\n          const node = entry.target;\n\n          // If there are no subscribers, bail\n          if (!this.subscribers.has(node)) return;\n\n          const subscriber = this.subscribers.get(node);\n          if (entry.isIntersecting && subscriber.enterCallback !== undefined) {\n            subscriber.enterCallback(entry);\n\n            if (subscriber.once) {\n              observer.unobserve(node);\n              this.subscribers.delete(subscriber);\n            }\n          } else if (subscriber.leaveCallback !== undefined) {\n            subscriber.leaveCallback(entry);\n          }\n        });\n      },\n      options\n    );\n\n    this.subscribers = new Map();\n\n    return this;\n  }\n\n  /**\n   *\n   *\n   * @param {any} nodes\n   * @returns\n   */\n  observe(nodes) {\n    unflatten(nodes).forEach(node => this.intersectionObserver.observe(node));\n\n    return this;\n  }\n\n  /**\n   *\n   *\n   * @param {any} nodes\n   * @returns\n   */\n  unobserve(nodes) {\n    unflatten(nodes).forEach(node => this.intersectionObserver.unobserve(node));\n\n    return this;\n  }\n\n  /**\n   *\n   *\n   * @param {any} nodes\n   * @param {any} enterCallback\n   * @param {any} leaveCallback\n   * @returns\n   */\n  subscribe(nodes, enterCallback, leaveCallback) {\n    unflatten(nodes).forEach(node =>\n      this.subscribers.set(node, {\n        once: false,\n        enterCallback,\n        leaveCallback\n      })\n    );\n\n    return this;\n  }\n\n  /**\n   *\n   *\n   * @param {any} nodes\n   * @param {any} enterCallback\n   * @returns\n   */\n  subscribeOnce(nodes, enterCallback) {\n    unflatten(nodes).forEach(node =>\n      this.subscribers.set(node, {\n        once: true,\n        enterCallback\n      })\n    );\n\n    return this;\n  }\n\n  /**\n   *\n   *\n   */\n  disconnect() {\n    this.intersectionObserver.disconnect();\n  }\n\n  /**\n   *\n   *\n   * @returns\n   */\n  takeRecords() {\n    return this.intersectionObserver.takeRecords();\n  }\n}\n"],"names":["unflatten","array","Array","isArray","options","intersectionObserver","IntersectionObserver","entries","observer","forEach","entry","node","target","this","subscribers","has","subscriber","get","isIntersecting","undefined","enterCallback","once","unobserve","delete","leaveCallback","Map","observe","nodes","subscribe","set","subscribeOnce","disconnect","takeRecords"],"mappings":"AAAe,SAASA,EAAUC,GAChC,OAAOC,MAAMC,QAAQF,GAASA,GAASA,GCCzC,MACE,SAAYG,0BACLC,qBAAuB,IAAIC,8BAC7BC,EAASC,KACAC,iBAAQC,OACRC,EAAOD,EAAME,UAGdC,EAAKC,YAAYC,IAAIJ,QAEpBK,EAAaH,EAAKC,YAAYG,IAAIN,GACpCD,EAAMQ,qBAA+CC,IAA7BH,EAAWI,iBAC1BA,cAAcV,GAErBM,EAAWK,SACJC,UAAUX,KACdG,YAAYS,OAAOP,UAEYG,IAA7BH,EAAWQ,iBACTA,cAAcd,OAI/BN,QAGGU,YAAc,IAAIW,IAEhBZ,kBASTa,iBAAQC,uBACIA,GAAOlB,iBAAQE,UAAQE,EAAKR,qBAAqBqB,QAAQf,KAE5DE,kBASTS,mBAAUK,uBACEA,GAAOlB,iBAAQE,UAAQE,EAAKR,qBAAqBiB,UAAUX,KAE9DE,kBAWTe,mBAAUD,EAAOP,EAAeI,uBACpBG,GAAOlB,iBAAQE,UACvBE,EAAKC,YAAYe,IAAIlB,SACb,gBACNS,gBACAI,MAIGX,kBAUTiB,uBAAcH,EAAOP,uBACTO,GAAOlB,iBAAQE,UACvBE,EAAKC,YAAYe,IAAIlB,SACb,gBACNS,MAIGP,kBAOTkB,2BACO1B,qBAAqB0B,0BAQ5BC,8BACSnB,KAAKR,qBAAqB2B"}